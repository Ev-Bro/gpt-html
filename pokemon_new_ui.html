<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokémon Type Battle Simulator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        #game-area {
            position: relative;
            background-color: #1a1a1a;
            border: 2px solid #333;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .entity {
            position: absolute;
            text-align: center;
            user-select: none;
            transition: width 0.3s ease, height 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .health-bar-container {
            position: absolute;
            bottom: -6px;
            width: 80%;
            height: 4px;
            background-color: #444;
            border-radius: 2px;
            border: 1px solid #111;
        }

        .health-bar {
            width: 100%;
            height: 100%;
            background-color: #22c55e;
            /* green-500 */
            border-radius: 2px;
            transition: width 0.2s ease;
        }

        .winner-banner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            background-color: rgba(0, 255, 127, 0.85);
            color: #111;
            font-size: 2.5rem;
            font-weight: 700;
            border-radius: 15px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px);
            z-index: 100;
            display: none;
        }

        #chart-container {
            height: 120px;
        }

        .damage-popup {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-weight: bold;
            font-size: 14px;
            animation: floatUp 0.7s ease-out forwards;
            z-index: 110;
            pointer-events: none;
        }

        @keyframes floatUp {
            from {
                opacity: 1;
                transform: translate(-50%, 0);
            }

            to {
                opacity: 0;
                transform: translate(-50%, -30px);
            }
        }

        .fight-line {
            position: absolute;
            background-color: red;
            height: 2px;
            transform-origin: 0 50%;
            z-index: 99;
        }

        .target-line {
            position: absolute;
            background-color: rgba(0, 255, 255, 0.8); /* Neon blue */
            height: 2px;
            transform-origin: 0 50%;
            z-index: 98; /* Below fight lines */
        }

        /* Map Size Classes */
        .game-area-small {
            width: 400px;
            height: 400px;
            aspect-ratio: 1 / 1;
        }

        .game-area-medium {
            width: 600px;
            height: 600px;
            aspect-ratio: 1 / 1;
        }

        .game-area-large {
            width: 800px;
            height: 800px;
            aspect-ratio: 1 / 1;
        }

        .game-area-mobile {
            width: 300px;
            height: 600px;
            aspect-ratio: unset;
        }

        /* For 'fit' mode, width/height are set by JS, but aspect-ratio can be default */
        .game-area-fit {
            aspect-ratio: 1 / 1;
        }

        .game-area-mobile {
            width: 300px !important;
            height: 600px !important;
            aspect-ratio: unset !important;
        }

        .mobile-game-area {
            width: 300px;
            height: 600px;
            aspect-ratio: unset;
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-100 flex flex-col items-center justify-center min-h-screen p-4 gap-8">

    <div class="flex flex-col lg:grid lg:grid-cols-[auto_1fr_auto] items-start justify-center gap-8">
        <!-- Left Sidebar -->
        <div id="left-sidebar" class="w-full lg:w-64 bg-gray-800 p-6 rounded-lg shadow-lg flex flex-col gap-4 order-first lg:order-none">
            <h2 class="text-lg font-semibold mb-2 text-gray-300">Controls</h2>
            <div class="flex flex-col gap-4">
                <div class="grid grid-cols-2 gap-3">
                    <button id="autoplay-btn"
                        class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded-lg transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400">Autoplay:
                        Off</button>
                    <button id="map-size-btn"
                        class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded-lg transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400">Map:
                        Medium</button>
                </div>
                <div class="grid grid-cols-2 gap-3">
                    <button id="toggle-damage-btn"
                        class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded-lg transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400">
                        Damage: Off
                    </button>
                    <button id="toggle-fight-lines-btn"
                        class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded-lg transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400">
                        Fight Lines: Off
                    </button>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-2 text-center">Speed</label>
                    <div class="flex items-center justify-center gap-2">
                        <button id="decrease-speed-btn"
                            class="w-12 h-10 bg-gray-600 hover:bg-gray-500 rounded-lg font-bold text-xl transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400">-</button>
                        <span id="speed-display"
                            class="font-bold text-lg w-20 text-center bg-gray-700 py-1.5 rounded-md">1.0x</span>
                        <button id="increase-speed-btn"
                            class="w-12 h-10 bg-gray-600 hover:bg-gray-500 rounded-lg font-bold text-xl transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400">+</button>
                    </div>
                    <div class="grid grid-cols-3 gap-2 mt-2">
                        <button id="min-speed-btn"
                            class="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-1.5 px-2 rounded-lg transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400 text-xs">Min</button>
                        <button id="default-speed-btn"
                            class="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-1.5 px-2 rounded-lg transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400 text-xs">1x</button>
                        <button id="max-speed-btn"
                            class="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-1.5 px-2 rounded-lg transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400 text-xs">Max</button>
                    </div>
                </div>

                <button id="restart-btn"
                    class="w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-4 rounded-lg transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-indigo-400">New
                    Round</button>
                <button id="pause-resume-btn"
                    class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400">Pause</button>
                <button id="toggle-target-lines-btn"
                    class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded-lg transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400">Target
                    Lines: Off</button>
                <button id="toggle-sudden-death-btn"
                    class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded-lg transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400">Sudden
                    Death Start: Off</button>
            </div>
        </div>

        <!-- Game Area and Status Messages -->
        <div class="flex flex-col items-center">
            <div id="game-area" class="rounded-lg">
                <div id="winner-banner" class="winner-banner"></div>
            </div>
            <div id="game-status-container" class="h-16 mt-2 text-center">
                <div id="sudden-death-message" class="hidden text-red-500 font-bold text-2xl uppercase">SUDDEN DEATH
                </div>
                <div id="remaining-types-icons" class="hidden text-3xl flex justify-center items-center"></div>
            </div>
        </div>

        <!-- Stats and Controls Panel (Right Sidebar) -->
        <div id="controls-panel" class="w-full lg:w-96 bg-gray-800 p-6 rounded-lg shadow-lg flex flex-col gap-4">
            <div>
                <h1 class="text-2xl font-bold text-white">Pokémon Type Sim</h1>
                <p class="text-sm text-gray-400">Watch the type battle unfold.</p>
            </div>

            <div class="w-full h-px bg-gray-700"></div>

            <!-- Current Round Stats -->
            <div>
                <h2 class="text-lg font-semibold mb-2 text-gray-300">Population</h2>
                <div id="population-stats" class="grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                    <!-- Population counts will be dynamically inserted here -->
                </div>
            </div>

            <!-- Population Graph -->
            <div id="chart-container"><canvas id="population-chart"></canvas></div>

            <div class="w-full h-px bg-gray-700"></div>

            <!-- Round Info -->
            <div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Round</span><span
                        id="round-number" class="font-bold">0</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Conversions</span><span
                        id="conversions-count" class="font-bold">0</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Elapsed Time</span><span
                        id="time-elapsed" class="font-bold">0.0s</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Remaining Types</span><span
                        id="remaining-types" class="font-bold">0</span></div>
            </div>

            <div class="w-full h-px bg-gray-700"></div>

            <!-- Winner History -->
            <div>
                <h2 class="text-lg font-semibold mb-2 text-gray-300">Round History</h2>
                <div id="winner-history" class="space-y-1 text-sm h-24 overflow-y-auto pr-2">
                    <!-- Winner history will be dynamically inserted here -->
                </div>
            </div>

            <div class="w-full h-px bg-gray-700"></div>
        </div>
    </div>

    <!-- Type Chart -->
    <div class="w-full max-w-7xl mt-8 p-4 bg-gray-800 rounded-lg shadow-lg">
        <h2 class="text-xl font-bold text-white text-center mb-4">Type Effectiveness Chart</h2>
        <div class="overflow-x-auto">
            <table class="w-full text-xs text-center text-gray-300">
                <thead class="bg-gray-700">
                    <tr>
                        <th class="p-2 border border-gray-600">Type</th>
                        <th class="p-2 border border-gray-600">Strong Against (×2)</th>
                        <th class="p-2 border border-gray-600">Weak To (×2)</th>
                        <th class="p-2 border border-gray-600">Resistant To (½)</th>
                        <th class="p-2 border border-gray-600">Immune To (0)</th>
                    </tr>
                </thead>
                <tbody id="type-chart-body" class="divide-y divide-gray-600">
                    <!-- Type chart rows will be dynamically inserted here -->
                </tbody>
            </table>
        </div>
    </div>


    <script>
        // --- DOM Elements ---
        const gameArea = document.getElementById('game-area');
        const populationStatsEl = document.getElementById('population-stats');
        const conversionsCountEl = document.getElementById('conversions-count');
        const timeElapsedEl = document.getElementById('time-elapsed');
        const restartBtn = document.getElementById('restart-btn');
        const winnerBanner = document.getElementById('winner-banner');
        const chartCanvas = document.getElementById('population-chart');
        const decreaseSpeedBtn = document.getElementById('decrease-speed-btn');
        const increaseSpeedBtn = document.getElementById('increase-speed-btn');
        const speedDisplay = document.getElementById('speed-display');
        const mapSizeBtn = document.getElementById('map-size-btn');
        const winnerHistoryEl = document.getElementById('winner-history');
        const roundNumberEl = document.getElementById('round-number');
        const minSpeedBtn = document.getElementById('min-speed-btn');
        const defaultSpeedBtn = document.getElementById('default-speed-btn');
        const maxSpeedBtn = document.getElementById('max-speed-btn');
        const typeChartBody = document.getElementById('type-chart-body');
        const stalemateTimerEl = document.getElementById('stalemate-timer');
        const remainingTypesEl = document.getElementById('remaining-types');
        const suddenDeathMessageEl = document.getElementById('sudden-death-message');
        const remainingTypesIconsEl = document.getElementById('remaining-types-icons');
        const autoplayBtn = document.getElementById('autoplay-btn');
        const toggleDamageBtn = document.getElementById('toggle-damage-btn');
        const toggleFightLinesBtn = document.getElementById('toggle-fight-lines-btn');
        const pauseResumeBtn = document.getElementById('pause-resume-btn');
        const toggleTargetLinesBtn = document.getElementById('toggle-target-lines-btn');
        const toggleSuddenDeathBtn = document.getElementById('toggle-sudden-death-btn');

        // enforce “off” look
        toggleDamageBtn.textContent = 'Damage: Off';
        toggleDamageBtn.classList.remove('bg-green-600', 'hover:bg-green-500');
        toggleDamageBtn.classList.add('bg-gray-600', 'hover:bg-gray-500');

        toggleFightLinesBtn.textContent = 'Fight Lines: Off';
        toggleFightLinesBtn.classList.remove('bg-green-600', 'hover:bg-green-500');
        toggleFightLinesBtn.classList.add('bg-gray-600', 'hover:bg-gray-500');

        // New buttons default to "Off" look
        toggleTargetLinesBtn.textContent = 'Target Lines: Off';
        toggleTargetLinesBtn.classList.remove('bg-green-600', 'hover:bg-green-500');
        toggleTargetLinesBtn.classList.add('bg-gray-600', 'hover:bg-gray-500');

        toggleSuddenDeathBtn.textContent = 'Sudden Death Start: Off';
        toggleSuddenDeathBtn.classList.remove('bg-green-600', 'hover:bg-green-500');
        toggleSuddenDeathBtn.classList.add('bg-gray-600', 'hover:bg-gray-500');


        // --- Game Configuration ---
        const ENTITY_COUNT = 180;
        const BASE_ENTITY_SPEED = 50;
        const GRAPH_UPDATE_INTERVAL = 200; // ms
        const MAX_GRAPH_POINTS = 120;
        const INITIAL_HP = 3;
        const INVINCIBILITY_DURATION = 250;
        const BASE_STALEMATE_SECONDS = 40; // Base time at 1x speed

        const SPRITE_SIZE = 32;
        const MAP_SIZES = { small: 400, medium: 600, large: 800, fit: 'fit', mobile: 'mobile' };
        const MOVEMENT_MODES = ['paths', 'targeted'];

        // --- Game State ---
        let entities = [];
        let gameLoopId = null;
        let conversions = 0;
        let startTime = 0;
        let populationChart = null;
        let lastGraphUpdate = 0;
        let speedMultiplier = 1.0;
        let winnerHistory = [];
        let roundCounter = 0;
        let lastTypeCount = 0;
        let timeTypeCountLastChanged = 0;
        let stalemateModeActive = false;
        let isAutoplayEnabled = false;
        let autoplayTimeoutId = null;
        let showDamageNumbers = false;
        let showFightLines = false;
        let fightLines = []; // Stores active fight line data
        let showSmoothing = true; // Default to true (smoothing on)
        let isPaused = false; // New state for pause/resume
        let showTargetLines = false; // New state for target lines
        let forceSuddenDeath = false; // New state for forcing sudden death
        let targetLines = []; // Stores active target line data

        const MAP_SIZE_KEYS = Object.keys(MAP_SIZES);
        let currentMapSizeIndex = 1; // medium
        let currentMovementModeIndex = 0; // paths

        // --- Pokémon Type System ---
        const TYPES = {
            NORMAL: 'Normal', FIRE: 'Fire', WATER: 'Water', ELECTRIC: 'Electric', GRASS: 'Grass',
            ICE: 'Ice', FIGHTING: 'Fighting', POISON: 'Poison', GROUND: 'Ground', FLYING: 'Flying',
            PSYCHIC: 'Psychic', BUG: 'Bug', ROCK: 'Rock', GHOST: 'Ghost', DRAGON: 'Dragon',
            DARK: 'Dark', STEEL: 'Steel', FAIRY: 'Fairy'
        };

        const TYPE_KEYS = Object.values(TYPES);

        const TYPE_IMAGES = {
            [TYPES.NORMAL]: 'images/normal.png', [TYPES.FIRE]: 'images/fire.png', [TYPES.WATER]: 'images/water.png', [TYPES.GRASS]: 'images/grass.png',
            [TYPES.ELECTRIC]: 'images/electric.png', [TYPES.ICE]: 'images/ice.png', [TYPES.FIGHTING]: 'images/fighting.png', [TYPES.POISON]: 'images/poison.png',
            [TYPES.GROUND]: 'images/ground.png', [TYPES.FLYING]: 'images/flying.png', [TYPES.PSYCHIC]: 'images/psychic.png', [TYPES.BUG]: 'images/bug.png',
            [TYPES.ROCK]: 'images/rock.png', [TYPES.GHOST]: 'images/ghost.png', [TYPES.DRAGON]: 'images/dragon.png', [TYPES.DARK]: 'images/dark.png',
            [TYPES.STEEL]: 'images/steel.png', [TYPES.FAIRY]: 'images/fairy.png'
        };

        const TYPE_COLORS = {
            [TYPES.NORMAL]: '#A8A77A', [TYPES.FIRE]: '#EE8130', [TYPES.WATER]: '#6390F0', [TYPES.GRASS]: '#7AC74C',
            [TYPES.ELECTRIC]: '#F7D02C', [TYPES.ICE]: '#96D9D6', [TYPES.FIGHTING]: '#C22E28', [TYPES.POISON]: '#A33EA1',
            [TYPES.GROUND]: '#E2BF65', [TYPES.FLYING]: '#A98FF3', [TYPES.PSYCHIC]: '#F95587', [TYPES.BUG]: '#A6B91A',
            [TYPES.ROCK]: '#B6A136', [TYPES.GHOST]: '#735797', [TYPES.DRAGON]: '#6F35FC', [TYPES.DARK]: '#705746',
            [TYPES.STEEL]: '#B7B7CE', [TYPES.FAIRY]: '#D685AD'
        };

        const TYPE_CHART = {};

        function setupTypeChart() {
            // Reset chart to default (all 1x)
            TYPE_KEYS.forEach(attacker => {
                TYPE_CHART[attacker] = {};
                TYPE_KEYS.forEach(defender => {
                    TYPE_CHART[attacker][defender] = 1;
                });
            });

            const setEffectiveness = (attacker, effectiveness, defenders) => {
                if (!defenders || defenders.length === 0) return;
                defenders.forEach(defender => {
                    if (TYPE_CHART[attacker] && TYPE_KEYS.includes(defender)) {
                        TYPE_CHART[attacker][defender] = effectiveness;
                    }
                });
            };

            // --- "4-5-4" BALANCED CLOCK ---
            const clockOrder = [
                TYPES.NORMAL, TYPES.FIRE, TYPES.WATER, TYPES.ELECTRIC, TYPES.GRASS, TYPES.ICE,
                TYPES.FIGHTING, TYPES.POISON, TYPES.GROUND, TYPES.FLYING, TYPES.PSYCHIC,
                TYPES.BUG, TYPES.ROCK, TYPES.GHOST, TYPES.DRAGON, TYPES.DARK, TYPES.STEEL, TYPES.FAIRY
            ];
            const numTypes = clockOrder.length;

            for (let i = 0; i < numTypes; i++) {
                const attacker = clockOrder[i];

                // Strong (x2) vs 4 types ahead
                const strongTargets = [
                    clockOrder[(i + 1) % numTypes], clockOrder[(i + 2) % numTypes],
                    clockOrder[(i + 3) % numTypes], clockOrder[(i + 4) % numTypes]
                ];
                setEffectiveness(attacker, 2, strongTargets);

                // Resistant (x0.5) vs 5 types further ahead
                const resistantTargets = [
                    clockOrder[(i + 5) % numTypes], clockOrder[(i + 6) % numTypes],
                    clockOrder[(i + 7) % numTypes], clockOrder[(i + 8) % numTypes],
                    clockOrder[(i + 9) % numTypes]
                ];
                setEffectiveness(attacker, 0.5, resistantTargets);

                // Immune (x0) vs 4 types opposite
                const immuneTargets = [
                    clockOrder[(i + 10) % numTypes], clockOrder[(i + 11) % numTypes],
                    clockOrder[(i + 12) % numTypes], clockOrder[(i + 13) % numTypes]
                ];
                setEffectiveness(attacker, 0, immuneTargets);
            }
        }

        function updateTypeChartTable() {
            typeChartBody.innerHTML = '';
            TYPE_KEYS.forEach(attacker => {
                const strong = [], weak = [], resistant = [], immune = [];

                TYPE_KEYS.forEach(defender => {
                    // Attacking relationships (Attacker -> Defender)
                    const effectiveness = TYPE_CHART[attacker][defender];
                    if (effectiveness === 2) strong.push(defender);
                    if (effectiveness === 0.5) resistant.push(defender);
                    if (effectiveness === 0) immune.push(defender);

                    // Defending relationships (Defender -> Attacker)
                    const weakness = TYPE_CHART[defender][attacker];
                    if (weakness === 2) weak.push(defender);
                });

                const row = document.createElement('tr');
                row.className = 'bg-gray-800 hover:bg-gray-700';
                row.innerHTML = '<td class="p-2 border-r border-gray-600 font-semibold">' + attacker + '</td><td class="p-2 border-r border-gray-600">' + strong.join(', ') + '</td><td class="p-2 border-r border-gray-600">' + weak.join(', ') + '</td><td class="p-2 border-r border-gray-600">' + resistant.join(', ') + '</td><td class="p-2 border-r border-gray-600">' + immune.join(', ') + '</td>';
                typeChartBody.appendChild(row);
            });
        }

        /**
         * Creates an HTML string for a type icon image with a fallback to text.
         * @param {string} type - The Pokémon type.
         * @param {string} sizeClass - Tailwind CSS classes for size.
         * @returns {string} - The HTML string for the image tag.
         */
        function createTypeIconString(type, sizeClass = 'w-5 h-5 inline-block mr-2 align-middle') {
            if (!type) return '';
            const src = TYPE_IMAGES[type];
            const color = TYPE_COLORS[type];

            const fallbackHTML = '<span class="font-bold" style="color:' + color + ';">' + type + '</span>';
            const onerror_code = "this.outerHTML = '" + fallbackHTML.replace(/'/g, "\\'") + "';";

            return '<img src="' + src + '" alt="' + type + '" class="' + sizeClass + '" onerror="' + onerror_code.replace(/"/g, '&quot;') + '">';
        }

        function showDamagePopup(entity, damage) {
            if (damage <= 0 || !showDamageNumbers) return;

            const popup = document.createElement('div');
            popup.textContent = damage;
            popup.className = 'damage-popup';

            if (damage === 2) { // Super effective
                popup.style.color = 'rgba(122, 255, 122, 0.9)'; // Light green
            } else if (damage === 0.5) { // Not very effective
                popup.style.color = 'rgba(255, 100, 100, 0.9)'; // Light red
            } else if (damage === 0) { // Immune
                popup.textContent = 'Immune';
                popup.style.color = 'rgba(150, 150, 150, 0.9)'; // Gray
            } else {
                popup.style.color = 'rgba(255, 200, 0, 0.9)'; // Default yellow for normal damage
            }

            entity.element.appendChild(popup);

            setTimeout(() => {
                if (popup.parentNode) {
                    popup.parentNode.removeChild(popup);
                }
            }, 680); // Slightly less than animation duration
        }

        function drawFightLine(entityA, entityB, currentTime) {
            if (!showFightLines) return;

            const lineDuration = 1000; // 1 second
            const expirationTime = currentTime + lineDuration;

            const line = document.createElement('div');
            line.className = 'fight-line';
            gameArea.appendChild(line);

            fightLines.push({ element: line, entityA: entityA, entityB: entityB, expirationTime: expirationTime });
        }

        function drawTargetLine(entityA, entityB, currentTime) {
            if (!showTargetLines) return;

            const lineDuration = 100; // Shorter duration for target lines
            const expirationTime = currentTime + lineDuration;

            const line = document.createElement('div');
            line.className = 'target-line';
            gameArea.appendChild(line);

            targetLines.push({ element: line, entityA: entityA, entityB: entityB, expirationTime: expirationTime });
        }


        class Entity {
            constructor(type, x, y) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.type = type;
                this.x = x;
                this.y = y;
                this.hp = INITIAL_HP;
                this.maxHp = INITIAL_HP;
                this.lastDamageTimestamp = 0;

                this.element = document.createElement('div');
                this.element.className = 'entity';

                const healthBarContainer = document.createElement('div');
                healthBarContainer.className = 'health-bar-container';
                this.healthBar = document.createElement('div');
                this.healthBar.className = 'health-bar';
                healthBarContainer.appendChild(this.healthBar);
                this.element.appendChild(healthBarContainer);

                this.createSprite(); // Create and append the initial sprite

                this.updateElementSize();
                gameArea.appendChild(this.element);

                const angle = Math.random() * 2 * Math.PI;
                this.dx = Math.cos(angle);
                this.dy = Math.sin(angle);

                this.pathChangeTimestamp = 0;
                this.resetPathTimer(performance.now());

                this.targetId = null;
                this.targetedCount = 0;
            }

            // Handles image loading errors by replacing the broken image with a text fallback.
            handleSpriteError() {
                if (!this.spriteEl || !this.spriteEl.parentNode) return;

                const textFallback = document.createElement('span');
                textFallback.textContent = this.type;
                textFallback.className = 'text-white text-xs font-bold bg-gray-700 px-1 py-0.5 rounded';

                this.spriteEl.parentNode.replaceChild(textFallback, this.spriteEl);
                this.spriteEl = textFallback;
            }

            // Creates a new sprite image element and attaches it to the entity.
            createSprite() {
                const sprite = document.createElement('img');
                sprite.src = TYPE_IMAGES[this.type];
                sprite.alt = this.type;
                sprite.className = 'w-full h-full';
                sprite.style.objectFit = 'contain'; // Prevent stretching
                sprite.onerror = this.handleSpriteError.bind(this);

                this.spriteEl = sprite;
                // Insert the sprite before the health bar
                this.element.insertBefore(this.spriteEl, this.element.firstChild);
            }

            updateHealthBar() {
                const hpPercent = Math.max(0, this.hp / this.maxHp);
                this.healthBar.style.width = `${hpPercent * 100}%`;
                if (hpPercent < 0.3) {
                    this.healthBar.style.backgroundColor = '#ef4444'; // red-500
                } else if (hpPercent < 0.6) {
                    this.healthBar.style.backgroundColor = '#f59e0b'; // amber-500
                } else {
                    this.healthBar.style.backgroundColor = '#22c55e'; // green-500
                }
            }

            takeDamage(damage, currentTime) {
                if (this.hp <= 0) return; // Already fainted
                if (currentTime - this.lastDamageTimestamp < INVINCIBILITY_DURATION) return; // Invincible

                showDamagePopup(this, damage);

                this.hp -= damage;
                this.updateHealthBar();
                if (damage > 0) {
                    this.lastDamageTimestamp = currentTime;
                }
            }

            resetPathTimer(currentTime) {
                const pathDuration = Math.random() * 4000 + 1000; // 1-5 seconds
                this.pathChangeTimestamp = currentTime + pathDuration;
            }

            updateElementSize() {
                this.element.style.width = `${SPRITE_SIZE}px`;
                this.element.style.height = `${SPRITE_SIZE}px`;
            }

            setPosition(newX, newY) {
                const gameBounds = gameArea.getBoundingClientRect();
                this.x = Math.max(0, Math.min(gameBounds.width - SPRITE_SIZE, newX));
                this.y = Math.max(0, Math.min(gameBounds.height - SPRITE_SIZE, newY));
                this.element.style.left = `${this.x}px`;
                this.element.style.top = `${this.y}px`;
            }

            updatePosition(dx, dy) { this.setPosition(this.x + dx, this.y + dy); }

            changeType(newType) {
                this.type = newType;

                // Update the existing sprite element's source
                if (this.spriteEl && this.spriteEl.tagName === 'IMG') {
                    this.spriteEl.src = TYPE_IMAGES[this.type];
                    this.spriteEl.alt = this.type;
                } else if (this.spriteEl) {
                    // If it was a text fallback, replace it with an image
                    if (this.spriteEl.parentNode) {
                        this.spriteEl.parentNode.removeChild(this.spriteEl);
                    }
                    this.createSprite();
                }

                this.hp = this.maxHp; // Reset HP
                this.updateHealthBar();
                conversions++;
                this.targetId = null; // Lose target on conversion
            }

            disappear() {
                this.element.remove();
                this.hp = -1; // Mark as permanently gone for filtering
            }
        }

        function getDistanceSq(a, b) { const dx = a.x - b.x; const dy = a.y - b.y; return dx * dx + dy * dy; }

        function init() {
            if (autoplayTimeoutId) {
                clearTimeout(autoplayTimeoutId);
                autoplayTimeoutId = null;
            }
            if (gameLoopId) cancelAnimationFrame(gameLoopId);

            roundCounter++;

            const currentMapSizeKey = MAP_SIZE_KEYS[currentMapSizeIndex];

            // Remove all existing map size classes
            gameArea.classList.remove('game-area-small', 'game-area-medium', 'game-area-large', 'game-area-fit', 'game-area-mobile');

            if (currentMapSizeKey === 'fit') {
                const padding = 32; // Total padding on one side (e.g., 16px left + 16px right)
                const gap = 32; // Gap between game area and sidebars

                const leftSidebar = document.getElementById('left-sidebar');
                const rightSidebar = document.getElementById('controls-panel');

                const leftSidebarWidth = leftSidebar ? leftSidebar.offsetWidth : 0;
                const rightSidebarWidth = rightSidebar ? rightSidebar.offsetWidth : 0;

                let availableWidth, availableHeight;
                if (window.innerWidth >= 1024) { // lg breakpoint
                    // Subtract both sidebar widths, plus two gaps (left-game, game-right), plus total padding
                    availableWidth = window.innerWidth - leftSidebarWidth - rightSidebarWidth - (2 * gap) - (2 * padding);
                    availableHeight = window.innerHeight - (2 * padding); // Assuming vertical padding is also applied
                } else {
                    // For smaller screens, sidebars stack vertically, so only horizontal padding applies to width
                    availableWidth = window.innerWidth - (2 * padding);
                    // Subtract heights of both sidebars (stacked), plus gaps, plus padding
                    availableHeight = window.innerHeight - (leftSidebar.offsetHeight + rightSidebar.offsetHeight) - (2 * gap) - (2 * padding);
                }
                const fitSize = Math.floor(Math.min(availableWidth, availableHeight));
                gameArea.style.width = `${fitSize}px`;
                gameArea.style.height = `${fitSize}px`;
                gameArea.classList.add('game-area-fit');
            } else if (currentMapSizeKey === 'mobile') {
                gameArea.style.width = ''; // Clear direct style to let CSS class take over
                gameArea.style.height = ''; // Clear direct style to let CSS class take over
                gameArea.classList.add('game-area-mobile');
            } else { // small, medium, large
                gameArea.style.width = ''; // Clear direct style to let CSS class take over
                gameArea.style.height = ''; // Clear direct style to let CSS class take over
                gameArea.classList.add(`game-area-${currentMapSizeKey}`);
            }

            // Remove debugging styles
            gameArea.style.backgroundColor = '';
            gameArea.style.border = '';
            gameArea.style.position = '';
            gameArea.style.overflow = '';
            console.log("Game Area Bounding Rect:", gameArea.getBoundingClientRect());

            gameArea.innerHTML = '';
            winnerBanner.style.display = 'none';
            gameArea.appendChild(winnerBanner);

            suddenDeathMessageEl.classList.add('hidden');
            remainingTypesIconsEl.classList.add('hidden');

            entities = [];
            conversions = 0;
            startTime = performance.now();
            lastGraphUpdate = 0;
            lastTypeCount = 0;
            timeTypeCountLastChanged = performance.now();
            stalemateModeActive = false;
            isPaused = false; // Reset pause state on new round
            pauseResumeBtn.textContent = 'Pause'; // Reset button text
            pauseResumeBtn.classList.remove('bg-red-600', 'hover:bg-red-500');
            pauseResumeBtn.classList.add('bg-gray-600', 'hover:bg-gray-500');
            showTargetLines = false; // Reset target lines state on new round
            toggleTargetLinesBtn.textContent = 'Target Lines: Off'; // Reset button text
            toggleTargetLinesBtn.classList.remove('bg-green-600', 'hover:bg-green-500');
            toggleTargetLinesBtn.classList.add('bg-gray-600', 'hover:bg-gray-500');
            fightLines = []; // Clear any existing fight lines
            gameArea.querySelectorAll('.fight-line').forEach(el => el.remove()); // Remove fight line elements from DOM
            targetLines = []; // Clear any existing target lines
            gameArea.querySelectorAll('.target-line').forEach(el => el.remove()); // Remove target line elements from DOM

            // Reset movement mode to paths by default
            currentMovementModeIndex = 0; // paths

            // Force sudden death if enabled
            if (forceSuddenDeath) {
                activateStalemateMode();
            }

            setupPopulationDisplay();
            setupTypeChart();
            updateTypeChartTable();

            setTimeout(() => {
                const gameBounds = gameArea.getBoundingClientRect();
                const numTypes = TYPE_KEYS.length;
                const currentEntityCount = (currentMapSizeKey === 'mobile') ? Math.floor(ENTITY_COUNT / 2) : ENTITY_COUNT;
                const entitiesPerType = Math.floor(currentEntityCount / numTypes);

                for (let i = 0; i < numTypes; i++) {
                    const type = TYPE_KEYS[i];
                    for (let j = 0; j < entitiesPerType; j++) {
                        const x = Math.random() * (gameBounds.width - SPRITE_SIZE);
                        const y = Math.random() * (gameBounds.height - SPRITE_SIZE);
                        entities.push(new Entity(type, x, y));
                    }
                }
                const remainder = currentEntityCount % numTypes;
                for (let i = 0; i < remainder; i++) {
                    const type = TYPE_KEYS[i];
                    const x = Math.random() * (gameBounds.width - SPRITE_SIZE);
                    const y = Math.random() * (gameBounds.height - SPRITE_SIZE);
                    entities.push(new Entity(type, x, y));
                }

                setupChart();
                gameLoopId = requestAnimationFrame(gameLoop);
            }, 50);
        }

        function resolveCollision(a, b, distSq) {
            const dist = Math.sqrt(distSq);
            const overlap = SPRITE_SIZE - dist;
            if (dist === 0) { a.updatePosition((Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1); return; }
            const nx = (a.x - b.x) / dist;
            const ny = (a.y - b.y) / dist;
            const moveX = nx * (overlap / 2);
            const moveY = ny * (overlap / 2);
            a.setPosition(a.x + moveX, a.y + moveY);
            b.setPosition(b.x - moveX, b.y - moveY);
        }

        let lastTimestamp = 0;
        function gameLoop(timestamp) {
            if (!lastTimestamp) lastTimestamp = timestamp;
            const deltaTime = (timestamp - lastTimestamp) / 1000;
            lastTimestamp = timestamp;

            if (isPaused) {
                gameLoopId = requestAnimationFrame(gameLoop);
                return; // Skip game logic if paused
            }

            const aliveEntities = entities.filter(e => e.hp > 0);

            const allTypes = new Set(entities.filter(e => e.hp > -1).map(e => e.type));
            if (allTypes.size <= 1) {
                endGame(allTypes.values().next().value);
                return;
            }

            const counts = {};
            TYPE_KEYS.forEach(key => counts[key] = 0);
            for (const entity of entities) {
                if (entity.hp > -1) counts[entity.type]++;
            }

            const currentTypeCount = Object.values(counts).filter(c => c > 0).length;
            if (currentTypeCount !== lastTypeCount) {
                lastTypeCount = currentTypeCount;
                timeTypeCountLastChanged = timestamp;
            }

            const currentEntitySpeed = BASE_ENTITY_SPEED * speedMultiplier;
            let movementMode = MOVEMENT_MODES[currentMovementModeIndex];
            if (stalemateModeActive) {
                movementMode = 'targeted';
            }
            const gameBounds = gameArea.getBoundingClientRect();

            // Reset targeted counts for this frame
            aliveEntities.forEach(e => e.targetedCount = 0);

            // --- Movement & Target Acquisition ---
            // Clear expired target lines and update active ones
            targetLines = targetLines.filter(line => {
                if (timestamp > line.expirationTime) {
                    if (line.element.parentNode) {
                        line.element.parentNode.removeChild(line.element);
                    }
                    return false;
                }

                // Update line position to follow entities
                const x1 = line.entityA.x + SPRITE_SIZE / 2;
                const y1 = line.entityA.y + SPRITE_SIZE / 2;
                const x2 = line.entityB.x + SPRITE_SIZE / 2;
                const y2 = line.entityB.y + SPRITE_SIZE / 2;

                const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

                line.element.style.position = 'absolute';
                line.element.style.left = `${x1}px`;
                line.element.style.top = `${y1}px`;
                line.element.style.width = `${distance}px`;
                line.element.style.transform = `rotate(${angle}deg)`;

                return true;
            });

            for (const entity of aliveEntities) {
                let hasTarget = false;

                if (movementMode === 'targeted') {
                    let currentTarget = aliveEntities.find(e => e.id === entity.targetId);

                    if (!currentTarget || currentTarget.type === entity.type) {
                        entity.targetId = null;
                        currentTarget = null;
                    }

                    if (!currentTarget && timestamp > entity.pathChangeTimestamp) {
                        let bestTarget = null;
                        let minDistanceSq = Infinity;

                        for (const potentialTarget of aliveEntities) {
                            if (entity.id === potentialTarget.id || entity.type === potentialTarget.type) continue;
                            if (potentialTarget.targetedCount >= 5) continue; // Limit targets to 5

                            const effectiveness = TYPE_CHART[entity.type][potentialTarget.type];
                            // Prioritize targets: Super effective (2) > Neutral (1) > Not very effective (0.5)
                            // Do not target immune (0)
                            if (effectiveness > 0) { // Only consider targets that are not immune
                                const distSq = getDistanceSq(entity, potentialTarget);
                                if (!bestTarget || effectiveness > TYPE_CHART[entity.type][bestTarget.type] || 
                                    (effectiveness === TYPE_CHART[entity.type][bestTarget.type] && distSq < minDistanceSq)) {
                                    minDistanceSq = distSq;
                                    bestTarget = potentialTarget;
                                }
                            }
                        }

                        if (bestTarget) {
                            entity.targetId = bestTarget.id;
                            bestTarget.targetedCount++;
                        }
                        entity.resetPathTimer(timestamp);
                    }

                    currentTarget = aliveEntities.find(e => e.id === entity.targetId);
                    if (currentTarget) {
                        const dist = Math.sqrt(getDistanceSq(entity, currentTarget));
                        if (dist > 1) {
                            entity.dx = (currentTarget.x - entity.x) / dist;
                            entity.dy = (currentTarget.y - entity.y) / dist;
                        }
                        hasTarget = true;
                        if (showTargetLines) {
                            drawTargetLine(entity, currentTarget, timestamp);
                        }
                    }
                }

                if (!hasTarget) {
                    if ((entity.x <= 0 && entity.dx < 0) || (entity.x >= gameBounds.width - SPRITE_SIZE && entity.dx > 0)) {
                        entity.dx *= -1;
                    }
                    if ((entity.y <= 0 && entity.dy < 0) || (entity.y >= gameBounds.height - SPRITE_SIZE && entity.dy > 0)) {
                        entity.dy *= -1;
                    }

                    if (movementMode === 'paths' && timestamp > entity.pathChangeTimestamp) {
                        const angle = Math.random() * 2 * Math.PI;
                        entity.dx = Math.cos(angle);
                        entity.dy = Math.sin(angle);
                        entity.resetPathTimer(timestamp);
                    }
                }

                if (entity.dx > 0) {
                    entity.spriteEl.style.transform = 'scaleX(1)';
                } else if (entity.dx < 0) {
                    entity.spriteEl.style.transform = 'scaleX(-1)';
                }

                entity.updatePosition(entity.dx * currentEntitySpeed * deltaTime, entity.dy * currentEntitySpeed * deltaTime);
            }

            // --- Battle Logic ---
            const changesToApply = [];
            const processedInFrame = new Set();

            // Clean up expired fight lines and update active ones
            fightLines = fightLines.filter(line => {
                if (timestamp > line.expirationTime) {
                    if (line.element.parentNode) {
                        line.element.parentNode.removeChild(line.element);
                    }
                    return false;
                }

                // Update line position to follow entities
                const x1 = line.entityA.x + SPRITE_SIZE / 2;
                const y1 = line.entityA.y + SPRITE_SIZE / 2;
                const x2 = line.entityB.x + SPRITE_SIZE / 2;
                const y2 = line.entityB.y + SPRITE_SIZE / 2;

                const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

                line.element.style.position = 'absolute';
                line.element.style.left = `${x1}px`;
                line.element.style.top = `${y1}px`;
                line.element.style.width = `${distance}px`;
                line.element.style.transform = `rotate(${angle}deg)`;

                return true;
            });

            // Clean up expired target lines and update active ones
            targetLines = targetLines.filter(line => {
                if (timestamp > line.expirationTime) {
                    if (line.element.parentNode) {
                        line.element.parentNode.removeChild(line.element);
                    }
                    return false;
                }

                // Update line position to follow entities
                const x1 = line.entityA.x + SPRITE_SIZE / 2;
                const y1 = line.entityA.y + SPRITE_SIZE / 2;
                const x2 = line.entityB.x + SPRITE_SIZE / 2;
                const y2 = line.entityB.y + SPRITE_SIZE / 2;

                const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

                line.element.style.position = 'absolute';
                line.element.style.left = `${x1}px`;
                line.element.style.top = `${y1}px`;
                line.element.style.width = `${distance}px`;
                line.element.style.transform = `rotate(${angle}deg)`;

                return true;
            });

            for (let j = 0; j < aliveEntities.length; j++) {
                for (let k = j + 1; k < aliveEntities.length; k++) {
                    const entityA = aliveEntities[j];
                    const entityB = aliveEntities[k];

                    if (processedInFrame.has(entityA.id) || processedInFrame.has(entityB.id)) continue;

                    const distanceSq = getDistanceSq(entityA, entityB);

                    if (distanceSq < SPRITE_SIZE * SPRITE_SIZE) {

                        if (entityA.type === entityB.type) continue;

                        const damageAdeals = TYPE_CHART[entityA.type][entityB.type];
                        const damageBdeals = TYPE_CHART[entityB.type][entityA.type];
                        entityA.takeDamage(damageBdeals, timestamp);
                        entityB.takeDamage(damageAdeals, timestamp);

                        // Draw fight line if enabled
                        drawFightLine(entityA, entityB, timestamp);

                        const aFainted = entityA.hp <= 0;
                        const bFainted = entityB.hp <= 0;

                        if (aFainted && !bFainted) {
                            changesToApply.push({ loser: entityA, winnerType: entityB.type });
                        } else if (bFainted && !aFainted) {
                            changesToApply.push({ loser: entityB, winnerType: entityA.type });
                        } else if (aFainted && bFainted) {
                            if (Math.random() < 0.5) {
                                changesToApply.push({ loser: entityB, winnerType: entityA.type });
                                entityA.hp = entityA.maxHp;
                                entityA.updateHealthBar();
                            } else {
                                changesToApply.push({ loser: entityA, winnerType: entityB.type });
                                entityB.hp = entityB.maxHp;
                                entityB.updateHealthBar();
                            }
                        } else {
                            resolveCollision(entityA, entityB, distanceSq);
                        }

                        processedInFrame.add(entityA.id);
                        processedInFrame.add(entityB.id);
                    }
                }
            }

            for (const change of changesToApply) {
                if (stalemateModeActive) {
                    change.loser.disappear();
                } else {
                    change.loser.changeType(change.winnerType);
                }
            }

            if (stalemateModeActive && changesToApply.length > 0) {
                entities = entities.filter(e => e.hp !== -1);
            }

            updateStats(counts, timestamp);
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function setupPopulationDisplay() {
            populationStatsEl.innerHTML = '';
            TYPE_KEYS.forEach(type => {
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center font-mono';
                div.innerHTML = '<span class="flex-shrink-0 flex items-center">' + createTypeIconString(type, 'w-5 h-5 inline-block mr-2 align-middle') + type + '</span><span id="' + type.toLowerCase() + '-count" class="font-bold ml-2" style="color: ' + TYPE_COLORS[type] + '">0</span>';
                populationStatsEl.appendChild(div);
            });
        }

        function updateStats(counts, timestamp) {
            TYPE_KEYS.forEach(type => {
                const el = document.getElementById(`${type.toLowerCase()}-count`);
                if (el) el.textContent = counts[type] || 0;
            });

            roundNumberEl.textContent = roundCounter;
            conversionsCountEl.textContent = conversions;
            const elapsedTime = ((performance.now() - startTime) / 1000);
            timeElapsedEl.textContent = `${elapsedTime.toFixed(1)}s`;

            const remainingTypes = Object.keys(counts).filter(type => counts[type] > 0);
            remainingTypesEl.textContent = remainingTypes.length;

            if (remainingTypes.length <= 4 && remainingTypes.length > 1) {
                remainingTypesIconsEl.innerHTML = remainingTypes.map(type => createTypeIconString(type, 'w-20 h-20 inline-block mx-1')).join(' <span class="mx-1 self-center">vs.</span> ');
                remainingTypesIconsEl.classList.remove('hidden');
            } else {
                remainingTypesIconsEl.classList.add('hidden');
            }

            const timeWithSameTypeCount = (timestamp - timeTypeCountLastChanged) / 1000;
            if (stalemateTimerEl) {
                stalemateTimerEl.textContent = `${timeWithSameTypeCount.toFixed(1)}s`;
            }

            const currentStalemateThreshold = BASE_STALEMATE_SECONDS / speedMultiplier;
            if (timeWithSameTypeCount > currentStalemateThreshold) {
                activateStalemateMode();
            }

            if (timestamp - lastGraphUpdate > GRAPH_UPDATE_INTERVAL) {
                lastGraphUpdate = timestamp;
                updateChart(counts, elapsedTime);
            }
        }

        function updateWinnerHistoryDisplay() {
            winnerHistoryEl.innerHTML = '';
            [...winnerHistory].reverse().forEach(entry => {
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center font-mono';
                div.innerHTML = '<span>Round ' + entry.round + '</span><span class="font-bold flex items-center" style="color: ' + TYPE_COLORS[entry.winner] + '">' + createTypeIconString(entry.winner, 'w-5 h-5 inline-block mr-1 align-middle') + entry.winner + '</span>';
                winnerHistoryEl.appendChild(div);
            });
        }

        function endGame(winnerType) {
            if (!gameLoopId) return;
            cancelAnimationFrame(gameLoopId);
            gameLoopId = null;
            lastTimestamp = 0;

            remainingTypesIconsEl.classList.add('hidden');
            suddenDeathMessageEl.classList.add('hidden');

            if (winnerType) {
                winnerBanner.innerHTML = '<div class="flex flex-col items-center justify-center">' + createTypeIconString(winnerType, 'w-24 h-24 mb-2') + '<span>' + winnerType + ' Wins!</span></div>';
                winnerBanner.style.backgroundColor = 'rgba(0, 255, 127, 0.85)';
                winnerBanner.style.display = 'block';
                if (!winnerHistory.some(entry => entry.round === roundCounter)) {
                    winnerHistory.push({ round: roundCounter, winner: winnerType });
                    updateWinnerHistoryDisplay();
                }
            } else {
                winnerBanner.textContent = 'Mutual Annihilation!';
                winnerBanner.style.backgroundColor = 'rgba(239, 68, 68, 0.85)'; // red-500
                winnerBanner.style.display = 'block';
            }

            if (isAutoplayEnabled) {
                autoplayTimeoutId = setTimeout(init, 3000);
            }
        }

        function activateStalemateMode() {
            if (stalemateModeActive) return;
            stalemateModeActive = true;
            suddenDeathMessageEl.classList.remove('hidden');
            currentMovementModeIndex = MOVEMENT_MODES.indexOf('targeted'); // Set movement to targeted
            console.log("Stalemate mode activated: Fainted Pokémon will now be removed.");
        }

        function setupChart() {
            if (populationChart) populationChart.destroy();
            const ctx = chartCanvas.getContext('2d');

            const datasets = TYPE_KEYS.map(type => ({
                label: type,
                data: [],
                borderColor: TYPE_COLORS[type],
                tension: 0.4,
                borderWidth: 2
            }));

            populationChart = new Chart(ctx, {
                type: 'line',
                data: { labels: [], datasets: datasets },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    animation: { duration: 0 },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(1) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    elements: { point: { radius: 0 } },
                    scales: {
                        x: { display: false },
                        y: { display: true, min: 0, max: 100, ticks: { color: '#9ca3af', callback: value => value + '%' } }
                    }
                }
            });
        }

        function updateChart(counts, elapsedTime) {
            const totalPopulation = Object.values(counts).reduce((sum, count) => sum + count, 0);
            const data = populationChart.data;
            data.labels.push(elapsedTime.toFixed(1));

            data.datasets.forEach((dataset, index) => {
                const type = TYPE_KEYS[index];
                const percentage = totalPopulation > 0 ? ((counts[type] || 0) / totalPopulation) * 100 : 0;
                dataset.data.push(percentage);
            });

            if (data.labels.length > MAX_GRAPH_POINTS) {
                data.labels.shift();
                data.datasets.forEach(dataset => dataset.data.shift());
            }
            populationChart.update('none');
        }

        function updateSpeedDisplay() {
            speedDisplay.textContent = `${speedMultiplier.toFixed(1)}x`;
        }

        function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

        // --- Event Listeners ---
        restartBtn.addEventListener('click', init);

        pauseResumeBtn.addEventListener('click', () => {
            isPaused = !isPaused;
            if (isPaused) {
                pauseResumeBtn.textContent = 'Resume';
                pauseResumeBtn.classList.remove('bg-gray-600', 'hover:bg-gray-500');
                pauseResumeBtn.classList.add('bg-red-600', 'hover:bg-red-500');
            } else {
                pauseResumeBtn.textContent = 'Pause';
                pauseResumeBtn.classList.remove('bg-red-600', 'hover:bg-red-500');
                pauseResumeBtn.classList.add('bg-gray-600', 'hover:bg-gray-500');
                gameLoopId = requestAnimationFrame(gameLoop); // Resume the loop
            }
        });

        mapSizeBtn.addEventListener('click', () => {
            currentMapSizeIndex = (currentMapSizeIndex + 1) % MAP_SIZE_KEYS.length;
            const sizeKey = MAP_SIZE_KEYS[currentMapSizeIndex];
            mapSizeBtn.textContent = `Map: ${capitalize(sizeKey)}`;
            init();
        });

        autoplayBtn.addEventListener('click', () => {
            isAutoplayEnabled = !isAutoplayEnabled;
            if (isAutoplayEnabled) {
                autoplayBtn.textContent = 'Autoplay: On';
                autoplayBtn.classList.remove('bg-gray-600', 'hover:bg-gray-500');
                autoplayBtn.classList.add('bg-green-600', 'hover:bg-green-500');
            } else {
                autoplayBtn.textContent = 'Autoplay: Off';
                autoplayBtn.classList.remove('bg-green-600', 'hover:bg-green-500');
                autoplayBtn.classList.add('bg-gray-600', 'hover:bg-gray-500');
                if (autoplayTimeoutId) {
                    clearTimeout(autoplayTimeoutId);
                    autoplayTimeoutId = null;
                }
            }
        });

        increaseSpeedBtn.addEventListener('click', () => {
            if (speedMultiplier < 4.0) {
                speedMultiplier = parseFloat((speedMultiplier + 0.2).toFixed(1));
                updateSpeedDisplay();
            }
        });

        decreaseSpeedBtn.addEventListener('click', () => {
            if (speedMultiplier > 0.2) {
                speedMultiplier = parseFloat((speedMultiplier - 0.2).toFixed(1));
                updateSpeedDisplay();
            }
        });

        minSpeedBtn.addEventListener('click', () => {
            speedMultiplier = 0.2;
            updateSpeedDisplay();
        });

        defaultSpeedBtn.addEventListener('click', () => {
            speedMultiplier = 1.0;
            updateSpeedDisplay();
        });

        maxSpeedBtn.addEventListener('click', () => {
            speedMultiplier = 4.0;
            updateSpeedDisplay();
        });

        toggleDamageBtn.addEventListener('click', () => {
            showDamageNumbers = !showDamageNumbers;
            if (showDamageNumbers) {
                toggleDamageBtn.textContent = 'Damage: On';
                toggleDamageBtn.classList.remove('bg-gray-600', 'hover:bg-gray-500');
                toggleDamageBtn.classList.add('bg-green-600', 'hover:bg-green-500');
            } else {
                toggleDamageBtn.textContent = 'Damage: Off';
                toggleDamageBtn.classList.remove('bg-green-600', 'hover:bg-green-500');
                toggleDamageBtn.classList.add('bg-gray-600', 'hover:bg-gray-500');
            }
        });

        toggleFightLinesBtn.addEventListener('click', () => {
            showFightLines = !showFightLines;
            if (showFightLines) {
                toggleFightLinesBtn.textContent = 'Fight Lines: On';
                toggleFightLinesBtn.classList.remove('bg-gray-600', 'hover:bg-gray-500');
                toggleFightLinesBtn.classList.add('bg-green-600', 'hover:bg-green-500');
            } else {
                toggleFightLinesBtn.textContent = 'Fight Lines: Off';
                toggleFightLinesBtn.classList.remove('bg-green-600', 'hover:bg-green-500');
                toggleFightLinesBtn.classList.add('bg-gray-600', 'hover:bg-gray-500');
            }
        });

        toggleTargetLinesBtn.addEventListener('click', () => {
            showTargetLines = !showTargetLines;
            if (showTargetLines) {
                toggleTargetLinesBtn.textContent = 'Target Lines: On';
                toggleTargetLinesBtn.classList.remove('bg-gray-600', 'hover:bg-gray-500');
                toggleTargetLinesBtn.classList.add('bg-green-600', 'hover:bg-green-500');
            } else {
                toggleTargetLinesBtn.textContent = 'Target Lines: Off';
                toggleTargetLinesBtn.classList.remove('bg-green-600', 'hover:bg-green-500');
                toggleTargetLinesBtn.classList.add('bg-gray-600', 'hover:bg-gray-500');
            }
        });

        toggleSuddenDeathBtn.addEventListener('click', () => {
            forceSuddenDeath = !forceSuddenDeath;
            if (forceSuddenDeath) {
                toggleSuddenDeathBtn.textContent = 'Sudden Death Start: On';
                toggleSuddenDeathBtn.classList.remove('bg-gray-600', 'hover:bg-gray-500');
                toggleSuddenDeathBtn.classList.add('bg-green-600', 'hover:bg-green-500');
            } else {
                toggleSuddenDeathBtn.textContent = 'Sudden Death Start: Off';
                toggleSuddenDeathBtn.classList.remove('bg-green-600', 'hover:bg-green-500');
                toggleSuddenDeathBtn.classList.add('bg-gray-600', 'hover:bg-gray-500');
            }
        });

        window.addEventListener('resize', init);

        // --- Preload Images ---
        function preloadImages(imageMap) {
            const promises = [];
            for (const key in imageMap) {
                if (imageMap.hasOwnProperty(key)) {
                    const img = new Image();
                    img.src = imageMap[key];
                    promises.push(new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = reject;
                    }));
                }
            }
            return Promise.all(promises);
        }

        window.onload = () => {
            preloadImages(TYPE_IMAGES).then(() => {
                console.log("All type images preloaded.");
                init();
            }).catch(error => {
                console.error("Error preloading images:", error);
                init(); // Proceed even if some images fail to load
            });
        };

    </script>
</body>

</html>