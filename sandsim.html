<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Particle Simulator Sandbox</title>
<style>
  :root{
    --bg:#121212;
    --panel:#1c1c1c;
    --text:#e8e8e8;
    --muted:#9aa0a6;
    --border:#2ecc71;
    --sand:#F2994A;
    --water:#2D9CDB;
    --wall:#9aa0a6;
    --stone:#2FA97C;
    --clear:#E74C3C;
    --eraser:#444;
    --btn-shadow:0 1px 0 rgba(255,255,255,.05) inset, 0 2px 10px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    background:var(--bg);
    color:var(--text);
    display:flex;
    flex-direction:column;
    align-items:center;
    min-height:100vh;
    gap:14px;
    padding:18px 10px 36px;
  }
  h1{
    margin:0;
    font-size: clamp(18px, 3.2vw, 32px);
    letter-spacing:.2px;
    font-weight:700;
    display:flex;
    align-items:center;
    gap:.5ch;
  }
  h1 .cup{filter:drop-shadow(0 2px 0 rgba(0,0,0,.35));}
  .toolbar{
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    align-items:center;
    justify-content:center;
    background:var(--panel);
    padding:10px 12px;
    border-radius:10px;
    border:1px solid #2a2a2a;
  }
  button{
    border:1px solid transparent;
    padding:8px 12px;
    border-radius:8px;
    font-weight:600;
    cursor:pointer;
    color:#101010;
    box-shadow:var(--btn-shadow);
    transition:transform .05s ease;
    user-select:none;
  }
  button:active{ transform:translateY(1px); }
  .sand{ background:var(--sand); }
  .water{ background:var(--water); color:white; }
  .wall{ background:var(--wall); }
  .stone{ background:var(--stone); }
  .eraser{ background:var(--eraser); color:#eaeaea; }
  .clear{ background:var(--clear); color:white; }
  .active{
    outline:2px solid #fff5;
  }
  .slider-wrap{ display:flex; align-items:center; gap:10px; color:var(--muted); margin-left:4px; }
  .slider-wrap input[type=range]{ accent-color:#79ffa7; }
  .sim-wrap{
    background:#0c0c0c;
    padding:10px;
    border-radius:12px;
    border:1px solid #2a2a2a;
  }
  canvas{
    image-rendering: pixelated;
    background:#000;
    border:2px solid var(--border);
    border-radius:6px;
    cursor: crosshair;
    display:block;
    max-width: 92vw;
    height:auto;
  }
  .hint{
    color:var(--muted);
    font-size:.92rem;
    text-align:center;
    max-width:900px;
    line-height:1.3;
  }
  .legend{
    color:var(--muted);
    display:flex;
    gap:8px;
    justify-content:center;
    flex-wrap:wrap;
  }
  .legend span{ display:inline-flex; align-items:center; gap:6px; }
  .dot{ width:14px; height:14px; border-radius:3px; display:inline-block; }
  .dot.sand{ background:var(--sand); }
  .dot.water{ background:var(--water); }
  .dot.wall{ background:var(--wall); }
  .dot.stone{ background:var(--stone); }
  .footer{
    margin-top:6px;
    color:var(--muted);
    font-size:.85rem;
  }
</style>
</head>
<body>
  <h1><span class="cup">üèÜ</span>Particle Simulator Sandbox</h1>

  <div class="toolbar" role="toolbar" aria-label="materials and actions">
    <button id="tool-sand" class="sand">Sand</button>
    <button id="tool-water" class="water">Water</button>
    <button id="tool-wall" class="wall">Wall</button>
    <button id="tool-stone" class="stone">Stone</button>
    <button id="tool-eraser" class="eraser" title="Erase particles">Eraser</button>
    <button id="clear" class="clear" title="Clear the whole board">Clear</button>
    <div class="slider-wrap">
      <label for="brush">Brush size:</label>
      <input id="brush" type="range" min="1" max="12" step="1" value="3" />
      <span id="brush-val">3</span>
    </div>
  </div>

  <div class="sim-wrap">
    <canvas id="sim" width="800" height="520" aria-label="particle sandbox"></canvas>
  </div>

  <div class="hint">
    Click and drag to create particles ‚Ä¢ Particles interact according to simple physics.
    <div class="legend" style="margin-top:6px;">
      <span><i class="dot sand"></i>Sand: falls &amp; piles up</span>
      <span><i class="dot water"></i>Water: flows &amp; spreads</span>
      <span><i class="dot wall"></i>Wall: blocks movement</span>
      <span><i class="dot stone"></i>Stone: heavy, falls fast</span>
    </div>
    <div class="footer">Press <b>P</b> to pause ‚Ä¢ <b>C</b> to clear ‚Ä¢ <b>[ / ]</b> to change brush</div>
  </div>

<script>
(() => {
  // --- Config ---
  const CELL_SIZE = 4;                // pixels per cell
  const W = 200;                      // grid width
  const H = 130;                      // grid height
  const FPS_CAP = 60;                 // draw cap
  const WATER_FLOW_PROB = 0.7;        // probability to try horizontal flow
  const DIAGONAL_BIAS = 0.5;          // bias for left/right randomness

  // Materials
  const EMPTY = 0, SAND = 1, WATER = 2, WALL = 3, STONE = 4;
  const COLORS = {
    [EMPTY]: '#000000',
    [SAND] : getComputedStyle(document.documentElement).getPropertyValue('--sand').trim(),
    [WATER]: getComputedStyle(document.documentElement).getPropertyValue('--water').trim(),
    [WALL] : getComputedStyle(document.documentElement).getPropertyValue('--wall').trim(),
    [STONE]: getComputedStyle(document.documentElement).getPropertyValue('--stone').trim()
  };

  // Canvas + state
  const cvs = document.getElementById('sim');
  // Fit internal canvas resolution from grid
  cvs.width  = W * CELL_SIZE;
  cvs.height = H * CELL_SIZE;

  const ctx = cvs.getContext('2d', { alpha:false });

  let grid = new Uint8Array(W * H);        // current
  let next = new Uint8Array(W * H);        // buffer
  let paused = false;

  // Tools
  let tool = SAND;
  const brush = document.getElementById('brush');
  const brushVal = document.getElementById('brush-val');

  const setActive = (id) => {
    document.querySelectorAll('.toolbar button').forEach(b => b.classList.remove('active'));
    document.getElementById(id).classList.add('active');
  };

  document.getElementById('tool-sand').addEventListener('click', () => { tool = SAND; setActive('tool-sand'); });
  document.getElementById('tool-water').addEventListener('click', () => { tool = WATER; setActive('tool-water'); });
  document.getElementById('tool-wall').addEventListener('click', () => { tool = WALL; setActive('tool-wall'); });
  document.getElementById('tool-stone').addEventListener('click', () => { tool = STONE; setActive('tool-stone'); });
  document.getElementById('tool-eraser').addEventListener('click', () => { tool = EMPTY; setActive('tool-eraser'); });
  document.getElementById('clear').addEventListener('click', () => clearGrid());

  // default tool
  setActive('tool-sand');

  // Brush slider
  brush.addEventListener('input', () => brushVal.textContent = brush.value);
  brushVal.textContent = brush.value;

  // Input handling
  let drawing = false;
  const toGrid = (clientX, clientY) => {
    const rect = cvs.getBoundingClientRect();
    const x = Math.floor((clientX - rect.left) / rect.width * cvs.width);
    const y = Math.floor((clientY - rect.top)  / rect.height * cvs.height);
    return { gx: Math.floor(x / CELL_SIZE), gy: Math.floor(y / CELL_SIZE) };
  };

  const paint = (gx, gy) => {
    const r = parseInt(brush.value, 10);
    for (let y = -r; y <= r; y++) {
      for (let x = -r; x <= r; x++) {
        if (x*x + y*y <= r*r) {
          const px = gx + x, py = gy + y;
          if (px >= 0 && px < W && py >= 0 && py < H) {
            grid[py * W + px] = tool;
          }
        }
      }
    }
  };

  const handlePointerDown = (e) => { drawing = true; const {gx, gy} = toGrid(e.clientX ?? e.touches[0].clientX, e.clientY ?? e.touches[0].clientY); paint(gx, gy); };
  const handlePointerMove = (e) => { if (!drawing) return; const t = e.touches ? e.touches[0] : e; const {gx, gy} = toGrid(t.clientX, t.clientY); paint(gx, gy); };
  const handlePointerUp   = () => { drawing = false; };

  cvs.addEventListener('mousedown', handlePointerDown);
  window.addEventListener('mousemove', handlePointerMove);
  window.addEventListener('mouseup', handlePointerUp);

  // touch
  cvs.addEventListener('touchstart', handlePointerDown, {passive:true});
  window.addEventListener('touchmove', handlePointerMove, {passive:true});
  window.addEventListener('touchend', handlePointerUp);

  // Keyboard
  window.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'p') paused = !paused;
    if (e.key.toLowerCase() === 'c') clearGrid();
    if (e.key === '[') brush.stepDown(); if (e.key === ']') brush.stepUp();
    brushVal.textContent = brush.value;
  });

  function clearGrid(){ grid.fill(EMPTY); }

  // --- Simulation helpers ---
  const idx = (x,y) => y*W + x;
  const inb = (x,y) => (x>=0 && x<W && y>=0 && y<H);

  function swap(x1,y1,x2,y2, g=grid){
    const a = idx(x1,y1), b = idx(x2,y2);
    const tmp = g[a]; g[a] = g[b]; g[b] = tmp;
  }

  function tryMove(x, y, nx, ny, canSwapWith = []){
    if (!inb(nx,ny)) return false;
    const from = idx(x,y), to = idx(nx,ny);
    const cur = grid[from], target = grid[to];
    if (target === EMPTY || canSwapWith.includes(target)) {
      grid[to] = cur;
      grid[from] = (canSwapWith.includes(target) ? target : EMPTY);
      return true;
    }
    return false;
  }

  // --- Update rules ---
  function step(){
    next.set(grid); // not strictly required, but helps stability

    const leftFirst = Math.random() < 0.5;

    for (let y = H-1; y >= 0; y--) {
      if (leftFirst){
        for (let x = 0; x < W; x++) { updateCell(x,y); }
      } else {
        for (let x = W-1; x >= 0; x--) { updateCell(x,y); }
      }
    }
  }

  function updateCell(x,y){
    const t = grid[idx(x,y)];
    if (t === EMPTY || t === WALL) return;

    if (t === SAND){
      if (tryMove(x,y, x, y+1, [WATER])) return;
      const dir = Math.random() < DIAGONAL_BIAS ? -1 : 1;
      if (tryMove(x,y, x+dir, y+1, [WATER])) return;
      if (tryMove(x,y, x-dir, y+1, [WATER])) return;
      return;
    }

    if (t === WATER){
      if (tryMove(x,y, x, y+1)) return; // fall
      if (Math.random() < WATER_FLOW_PROB){
        const dir = Math.random() < 0.5 ? -1 : 1;
        if (tryMove(x,y, x+dir, y)) return;
        if (tryMove(x,y, x-dir, y)) return;
      }
      const dir = Math.random() < 0.5 ? -1 : 1;
      if (tryMove(x,y, x+dir, y+1)) return;
      if (tryMove(x,y, x-dir, y+1)) return;
      return;
    }

    if (t === STONE){
      const crush = [WATER, SAND];
      if (tryMove(x,y, x, y+1, crush)) {
        if (tryMove(x,y+1, x, y+2, crush)) return;
        return;
      }
      const dir = Math.random() < 0.5 ? -1 : 1;
      if (tryMove(x,y, x+dir, y+1, crush)) return;
      if (tryMove(x,y, x-dir, y+1, crush)) return;
      return;
    }
  }

  // --- Render ---
  const image = ctx.createImageData(W, H);
  const data = image.data;

  function draw(){
    let p = 0;
    for (let i = 0; i < grid.length; i++){
      const c = COLORS[grid[i]];
      const r = parseInt(c.slice(1,3),16);
      const g = parseInt(c.slice(3,5),16);
      const b = parseInt(c.slice(5,7),16);
      data[p++] = r; data[p++] = g; data[p++] = b; data[p++] = 255;
    }
    ctx.putImageData(image, 0, 0);
    if (CELL_SIZE !== 1){
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(cvs, 0, 0, W, H, 0, 0, W*CELL_SIZE, H*CELL_SIZE);
    }
  }

  // --- Main loop ---
  let last = 0;
  function loop(ts){
    const dt = ts - last;
    if (dt >= (1000/FPS_CAP)){
      if (!paused) step();
      draw();
      last = ts;
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Start with an empty board (intentionally do nothing else)
  clearGrid();
})();
</script>
</body>
</html>
